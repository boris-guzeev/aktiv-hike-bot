// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: hikes.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHike = `-- name: CreateHike :one
INSERT INTO hikes (
    title_ru, 
    title_en, 
    description_ru, 
    description_en,
    starts_at, 
    ends_at, 
    photo_file_id, 
    is_published,
    created_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
RETURNING id, title_ru, title_en, description_ru, description_en, starts_at, ends_at, photo_file_id, is_published, created_at, updated_at
`

type CreateHikeParams struct {
	TitleRu       string      `db:"title_ru" json:"title_ru"`
	TitleEn       pgtype.Text `db:"title_en" json:"title_en"`
	DescriptionRu string      `db:"description_ru" json:"description_ru"`
	DescriptionEn pgtype.Text `db:"description_en" json:"description_en"`
	StartsAt      time.Time   `db:"starts_at" json:"starts_at"`
	EndsAt        time.Time   `db:"ends_at" json:"ends_at"`
	PhotoFileID   pgtype.Text `db:"photo_file_id" json:"photo_file_id"`
	IsPublished   bool        `db:"is_published" json:"is_published"`
	CreatedAt     time.Time   `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateHike(ctx context.Context, arg CreateHikeParams) (Hike, error) {
	row := q.db.QueryRow(ctx, createHike,
		arg.TitleRu,
		arg.TitleEn,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.StartsAt,
		arg.EndsAt,
		arg.PhotoFileID,
		arg.IsPublished,
		arg.CreatedAt,
	)
	var i Hike
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.DescriptionRu,
		&i.DescriptionEn,
		&i.StartsAt,
		&i.EndsAt,
		&i.PhotoFileID,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteHike = `-- name: DeleteHike :exec
DELETE FROM hikes WHERE id = $1
`

func (q *Queries) DeleteHike(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteHike, id)
	return err
}

const getHikeByID = `-- name: GetHikeByID :one
SELECT id, title_ru, title_en, description_ru, description_en, starts_at, ends_at, photo_file_id, is_published, created_at, updated_at FROM hikes WHERE id = $1
`

func (q *Queries) GetHikeByID(ctx context.Context, id int32) (Hike, error) {
	row := q.db.QueryRow(ctx, getHikeByID, id)
	var i Hike
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.DescriptionRu,
		&i.DescriptionEn,
		&i.StartsAt,
		&i.EndsAt,
		&i.PhotoFileID,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActualHikes = `-- name: ListActualHikes :many
SELECT id, title_ru, starts_at, ends_at, is_published
FROM hikes
WHERE is_published = true AND ends_at >= now()
ORDER BY starts_at ASC
LIMIT $1 OFFSET $2
`

type ListActualHikesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListActualHikesRow struct {
	ID          int32     `db:"id" json:"id"`
	TitleRu     string    `db:"title_ru" json:"title_ru"`
	StartsAt    time.Time `db:"starts_at" json:"starts_at"`
	EndsAt      time.Time `db:"ends_at" json:"ends_at"`
	IsPublished bool      `db:"is_published" json:"is_published"`
}

func (q *Queries) ListActualHikes(ctx context.Context, arg ListActualHikesParams) ([]ListActualHikesRow, error) {
	rows, err := q.db.Query(ctx, listActualHikes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActualHikesRow
	for rows.Next() {
		var i ListActualHikesRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsPublished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHikes = `-- name: ListHikes :many
SELECT 
    id, 
    title_ru, 
    description_ru,
    title_en,
    description_en,
    starts_at, 
    ends_at, 
    is_published, 
    created_at 
FROM 
    hikes 
ORDER BY is_published DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type ListHikesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListHikesRow struct {
	ID            int32       `db:"id" json:"id"`
	TitleRu       string      `db:"title_ru" json:"title_ru"`
	DescriptionRu string      `db:"description_ru" json:"description_ru"`
	TitleEn       pgtype.Text `db:"title_en" json:"title_en"`
	DescriptionEn pgtype.Text `db:"description_en" json:"description_en"`
	StartsAt      time.Time   `db:"starts_at" json:"starts_at"`
	EndsAt        time.Time   `db:"ends_at" json:"ends_at"`
	IsPublished   bool        `db:"is_published" json:"is_published"`
	CreatedAt     time.Time   `db:"created_at" json:"created_at"`
}

func (q *Queries) ListHikes(ctx context.Context, arg ListHikesParams) ([]ListHikesRow, error) {
	rows, err := q.db.Query(ctx, listHikes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHikesRow
	for rows.Next() {
		var i ListHikesRow
		if err := rows.Scan(
			&i.ID,
			&i.TitleRu,
			&i.DescriptionRu,
			&i.TitleEn,
			&i.DescriptionEn,
			&i.StartsAt,
			&i.EndsAt,
			&i.IsPublished,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPublished = `-- name: SetPublished :exec
UPDATE hikes
SET is_published = $1, updated_at = now()
WHERE id = $2
`

type SetPublishedParams struct {
	IsPublished bool  `db:"is_published" json:"is_published"`
	ID          int32 `db:"id" json:"id"`
}

func (q *Queries) SetPublished(ctx context.Context, arg SetPublishedParams) error {
	_, err := q.db.Exec(ctx, setPublished, arg.IsPublished, arg.ID)
	return err
}

const updateHike = `-- name: UpdateHike :one
UPDATE hikes SET
    title_ru       = $2,
    title_en       = $3,
    description_ru = $4,
    description_en = $5,
    starts_at      = $6,
    ends_at        = $7,
    photo_file_id  = $8,
    is_published   = $9,
    updated_at     = $10
WHERE id = $1
RETURNING id, title_ru, title_en, description_ru, description_en, starts_at, ends_at, photo_file_id, is_published, created_at, updated_at
`

type UpdateHikeParams struct {
	ID            int32       `db:"id" json:"id"`
	TitleRu       string      `db:"title_ru" json:"title_ru"`
	TitleEn       pgtype.Text `db:"title_en" json:"title_en"`
	DescriptionRu string      `db:"description_ru" json:"description_ru"`
	DescriptionEn pgtype.Text `db:"description_en" json:"description_en"`
	StartsAt      time.Time   `db:"starts_at" json:"starts_at"`
	EndsAt        time.Time   `db:"ends_at" json:"ends_at"`
	PhotoFileID   pgtype.Text `db:"photo_file_id" json:"photo_file_id"`
	IsPublished   bool        `db:"is_published" json:"is_published"`
	UpdatedAt     time.Time   `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateHike(ctx context.Context, arg UpdateHikeParams) (Hike, error) {
	row := q.db.QueryRow(ctx, updateHike,
		arg.ID,
		arg.TitleRu,
		arg.TitleEn,
		arg.DescriptionRu,
		arg.DescriptionEn,
		arg.StartsAt,
		arg.EndsAt,
		arg.PhotoFileID,
		arg.IsPublished,
		arg.UpdatedAt,
	)
	var i Hike
	err := row.Scan(
		&i.ID,
		&i.TitleRu,
		&i.TitleEn,
		&i.DescriptionRu,
		&i.DescriptionEn,
		&i.StartsAt,
		&i.EndsAt,
		&i.PhotoFileID,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
